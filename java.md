1. ArrayList和LinkedList的区别

2. HashMap的put流程

3. JVM、 哪些是共享区，哪些可以作为gc root
~~~t
  堆、方法区
  堆：年轻代、survivorFrom,to 老年代
  -Xmn 新生代内存大小,包括E区和两个S区的总和
  -Xms 初始堆大小，堆大小的最小值，默认是总物理内存/64(且小于1G)
  -Xmx 堆的最大值，默认值是总共的物理内存/64（且小于1G），如果Xms和Xmx都不设置，则两者大小会相同，默认情况下，当堆中可用内存大于70%
  gc root:栈中的本地变量、方法区的静态变量、本地方法栈的变量、正在运行的线程

  频繁Full GC 元数据使用还没有达到已分配的空间就导致了fgc，是因为元空间存在碎片化情况， 适当调大元空间大小 -xMaxMetaSpace
  频繁YGC -XX:MaxGCPauseMillis参数设置过小，导致JVM降低年轻代region大小
~~~

4. spring容器的创建流程

~~~t
a.首先会扫描所有的beanDefinition对象，并放入全局的map中
b.然后筛选出非懒加载的单例BeanDefinition对象进行创建，多例对象是在bean使用时通过BeanDefinition创建
c.创建Bean包括了合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，AOP在初始化后
~~~

5. spring的事务机制

~~~t
对于使用了@Transactional注解的Bean,spring会创建一个代理对象，当调用该代理对象方法时，会判断该方法上是否有@Transactional注解，但如果有则使用事务管理器创建一个数据库连接，并将该数据库连接的autocmmmit属性设置为false，当该方法运行成功无异常时提交事务，若出现异常并且是需要回滚的异常时会进行回滚操作，否则一样会进行事务提交
~~~

6. @Transactional失效

~~~t
a. 注解加在了非public方法上(Spring AOP 代理源码中判断方法是否是public修饰，不是则无法获取注解的配置信息)
b. 注解使用失效
c. 异常被catch，没有抛出
d. 非注解方法调用注解方法
~~~

7. Dubbo是如何做系统交互的

~~~t
1. 程序启动时，会自动启动dubbo的提供者，
2. 提供者会去注册中心将服务信息、版本、协议进行注册
3. 当消费者启动时，会去注册中心获取已经注册的服务
4. 当提供者信息发生变化时，有注册中心主动告知消费者
5. 消费者调用提供者的服务，同步请求
6. 每隔2分钟，提供者和消费者想监视器自动发送访问次数进行统计
~~~

8. Jdk1.7到Jdk1.8 java虚拟机发⽣了什么变化

~~~t
将1.7中的永久代删除，替换为元空间，二元空间的存储位置不是在虚拟机的内存中，二是改成了本地内存，原因是，方法区太小容易内存溢出,太大又会占用过多的虚拟机内存，所以放到了本地
~~~

9. 常⽤的SpringBoot注解，及其实现

~~~t
@SpringBootApplication注解：这个注解标识了⼀个SpringBoot⼯程，它实际上是另外三个注解的组合，这三个注解是：
a. @SpringBootConfiguration：这个注解实际就是⼀个@Configuration，表示启动类也是⼀个配置类
b. @EnableAutoConfiguration：⽤来加载ClassPath下SpringFactories中所定义的⾃动配置类，将这些⾃动加载为配置Bean
c. @ComponentScan：所以SpringBoot扫描的路径是启动类所在的当前⽬录
@Bean注解：⽤来定义Bean，类似于XML中的<bean>标签，Spring在启动时，会对加了@Bean注解的⽅法进⾏解析，将⽅法的名字做为beanName，并通过执⾏⽅法得到bean对象
~~~

10. 说说你了解的分布式锁实现

~~~t
基于Redis，Redis中的数据也是在内存，基于Redis的消费订阅功能、数据超时时间，lua脚本等功能，也能很好的实现的分布式锁
redisson实现流程
多线程去获取锁，未获取成功的会不停的去尝试获取直至超时，获取成功的会使用uuid+线程id作为key，同时会启动一个watchdog每10秒看下，是否还持有锁是否延长生存时间。根据hash算法选择一个redis节点进行执行业务。
如果使用的是主从模式，可以通过read lock的锁来避免主节点宕机从而丢失锁，readlock会将主节点加锁之后同步从节点后再返回客户端
~~~


11. Redis的数据结构及使⽤场景

~~~t
string
hash表
列表
集合
有序集合
~~~

12. Redis集群策略

~~~t
主从模式：这种模式⽐较简单，主库可以读写，并且会和从库进⾏数据同步，这种模式下，客户端直接连主库或某个从库，但是但主库或从库宕机后，客户端需要⼿动修改IP，另外，这种模式也⽐较难进⾏扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能⽀持特⼤数据量
哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择⼀个库作为进的主库，另外哨兵也可以做集群，从⽽可以保证但某⼀个哨兵节点宕机后，还有其他哨兵节点可以继续⼯作，这种模式可以⽐较好的保证Redis集群的⾼可⽤，但是仍然不能很好的解决Redis的容量上限问题。
Cluster模式：Cluster模式是⽤得⽐较多的模式，它⽀持多主多从，这种模式会按照key进⾏槽位的分配，可以使得不同的key分散到不同的主节点上，利⽤这种模式可以使得整个集群⽀持更⼤的数据容量，同时每个主节点可以拥有⾃⼰的多个从节点，如果该主节点宕机，会从它的从节点中选举⼀个新的主节点。
~~~

13. Innodb是如何实现事务的

~~~t
Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以⼀个update语句为例：
1.Innodb在收到⼀个update语句后，会先根据条件找到数据所在的⻚，并将该⻚缓存在Buffer Pool中
2.执⾏update语句，修改Buffer Pool中的数据，也就是内存中的数据
3针对update语句⽣成⼀个RedoLog对象，并存⼊LogBuffer中
4.针对update语句⽣成undolog⽇志，⽤于事务回滚
5.如果事务提交，那么则把RedoLog对象进⾏持久化，后续还有其他机制将Buffer Pool中所修改的数据⻚持久化到磁盘中
6.如果事务回滚，则利⽤undolog⽇志进⾏回滚
~~~

14. ConcurrentHashMap的原理

~~~t
JDK1.7中
由多个加锁的Segment组成，每个Segment里存在多个HashEntry,一个线程访问某个段时，别的线程可以访问其他段，这就实现了并发访问
JDK1.8中
移除了原先的Segment分段锁，采用了CAS+synchronized更细粒度级别的锁，加在链表的头部节点或者红黑树的根节点，不会影响其他数组的访问，实现了并发访问
~~~

15. ConcurrentHashMap的get方法是否需要加锁

~~~t
不需要，因为源码中在value,以及 next的变量上都添加了volatile关键字，对于其他线程来说都是可见可读的，所以不需要加锁
~~~

16. concurrentHashMap不支持value为null的原因

~~~t
是为了避免二义性，其工作场景是多线程，若get的结果是null,无法判断是没有对应的key还是key对应的值是null
~~~

17. concurrentHashMap的迭代器是强一致性还是弱一致性

~~~t
是弱一致性，面向多线程的，在遍历过程中可能就发生了变化，其迭代器在对已经遍历的部分发生的变化不会体现，对未遍历的部分变化了是会体现。
~~~

18. JDK1.8中为什么使用synchronized替换reentrantLock

~~~t
1.synchronized的性能得到了提升，从无锁-偏向锁-轻量级锁-重量级锁一步步的转化都是锁膨胀的优化。
2.从JDK1.7底层实现的原理来说，锁是加载段上的，一个段里会有多个链表，而1.8中锁是加在链表头部或者树的根部，锁的粒度更小了，并发度就提高了。
~~~

19. ConcurrentHashMap与Hashtable的效率哪个更高
~~~t
ConcurrentHashMap， 因为Hashtable是给整个哈希表加锁
~~~

20. 谈谈ConcurrentHashMap的扩容机制
~~~t
  1.7版本
  1. 1.7版本的ConcurrentHashMap是基于Segment分段实现的
  2. 每个Segment相对于⼀个⼩型的HashMap
  3. 每个Segment内部会进⾏扩容，和HashMap的扩容逻辑类似
  4. 先⽣成新的数组，然后转移元素到新数组中
  5. 扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值
  1.8版本
  1. 1.8版本的ConcurrentHashMap不再基于Segment实现
  2. 当某个线程进⾏put时，如果发现ConcurrentHashMap正在进⾏扩容那么该线程⼀起进⾏扩容
  3. 如果某个线程put时，发现没有正在进⾏扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进⾏扩容
  4. ConcurrentHashMap是⽀持多个线程同时扩容的
  5. 扩容之前也先⽣成⼀个新的数组
  6. 在转移元素时，先将原数组分组，将每组分给不同的线程来进⾏元素的转移，每个线程负责⼀组或多组的元素转移⼯作
~~~

21. 消息队列如何保证消息可靠传输
~~~t
  消息可靠传输代表了两层意思，既不能多也不能少。
  1. 为了保证消息不多，也就是消息不能重复，也就是⽣产者不能重复⽣产消息，或者消费者不能重复消费消息
    a. ⾸先要确保消息不多发，这个不常出现，也⽐较难控制，因为如果出现了多发，很⼤的原因是⽣产者⾃⼰的原因，如果要避免出现问题，就需要在消费端做控制
    b. 要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决⽣产者重复发送消息的问题
  2. 消息不能少，意思就是消息不能丢失，⽣产者发送的消息，消费者⼀定要能消费到，对于这个问题，就要考虑两个⽅⾯
    a. ⽣产者发送消息时，要确认broker确实收到并持久化了这条消息，⽐如RabbitMQ的confirm机制，Kafka的ack机制都可以保证⽣产者能正确的将消息发送给broker
    b. broker要等待消费者真正确认消费到了消息时才删除掉消息，这⾥通常就是消费端ack机制，消费者接收到⼀条消息后，如果确认没问题了，就可以给broker发送⼀个ack，broker接收到ack后才
会删除消息
~~~

22. 如果保证缓存和数据库一致性
~~~t
  1. 同步删除：会存在脏数据、所有更新数据库的地方都要进行删除缓存的操作
  2. 延时双删：延时无法确定、无法绝对保证
  3. 异步监听binlog删除+MQ重试
    a. 更新数据库
    b. 监听binlog删除缓存
    c. 缓存删除失败，通过MQ不断重试删除
~~~

23. I/O多路复用
~~~t
  1. 服务端：新建一个socket对象，绑定一个端口，通过调用listen函数将这个socket对象转为服务端的socket对象，通过accept方法接受客户端的请求
  2. 客户端：新建一个socket对象，通过connect方向想服务端发起连接请求，
  3. 双方各自建立了连接之后开发读写发送，
  4. 最终关闭连接

  模型：
  同步阻塞: 依次询问是否已经就绪，如果其中某一个未就绪，会等待它就绪后再询问下一个
  同步非阻塞：依次询问是否已经就绪，如果其中某一个未就绪，会跳过他询问下一个
  select/poll：已就绪的会发出信号，但是不知道是谁，还得一个一个询问
  epoll：已就绪的会发出信息，并且知道是哪一个已就绪，
~~~


24. MVC设计思想
~~~t
  以控制器为中心，将所有请求都交给控制器，由控制器进行分发，将响应的结果转给视图
~~~


25. 红黑树
~~~t
  1. 根节点是黑色， 叶子节点是不存储数据的黑色节点
  2. 任何相邻的两个节点不能同时为红色
  3. 任意节点到达叶子节点间都包含相同数量的黑色节点
~~~


22. Mysql中InnoDB, MyISAM的区别 ？

~~~t
1、InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高，但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，否则其他索引也会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。
2、InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败。
3、InnoDB 在 MySQL 5.6 之前不支持全文索引，而 MyISAM 一直都支持，如果你用的是老版本，查询效率上 MyISAM 要高。
4、InnoDB 锁粒度是行锁，而 MyISAM 是表锁。
5、InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条 SQL 语言放在 begin 和 commit 之间，组成一个事务。
6、InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快，但如果上述语句还包含了 where 子句，那么两者执行效率是一样的。
~~~

